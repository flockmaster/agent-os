# PRD: Codex Task Dispatcher (用户版)

> 版本: 3.0 | 日期: 2026-02-09 | 状态: 进行中

## 1. 项目概述

### 1.1 定位
构建一个 **三方协作的 AI 项目管理系统**，让开发工作像流水线一样自动运转：

| 角色 | 实体 | 职责 |
|------|------|------|
| **用户 (User)** | 您 | 提需求、确认 PRD、处理重大问题 |
| **项目经理 (PM)** | Antigravity | 分解需求、调度任务、回答问题、更新进度、**自主决策** |
| **工程师 (Worker)** | Codex | 执行原子任务、汇报结果、提出问题 |

### 1.2 核心理念

> **"您只需要说需求，然后去睡觉。醒来时，代码已经写好了。"**

- **最小打扰原则**：PM 能决定的事情，PM 直接决定。仅在重大或难以抉择的问题上才会打扰您。
- **智能跳过原则**：如果某个任务被阻塞（等待您回复但您不在），PM 会优先执行其他无关任务，而不是傻等。
- **上下文隔离原则**：每个 Worker 拥有全新的上下文窗口，彻底杜绝任务间的幻觉污染。

---

## 2. 核心功能

| 功能 | 描述 | 优势 |
|-----|------|------|
| **三方协作** | User → PM → Worker 的清晰职责链 | 模拟真实团队，可追溯 |
| **交互式调度** | PM 监控 Worker 进程，实时响应问题 | 不是 "Fire and Forget" |
| **自主决策** | PM 优先自行判断常见问题 | 减少打扰用户 |
| **智能跳过** | 阻塞任务不阻塞整体进度 | 您睡觉时工作仍继续 |
| **上下文隔离** | 每个任务由独立 Worker 执行 | 杜绝幻觉污染 |
| **单一真实源** | PRD 即进度表，实时更新 | 无需维护额外状态 |

---

## 3. 关键设计决策

| 决策点 | 选择 | 理由 |
|-------|------|-----|
| 调度模式 | **交互式** (非脚本) | PM 可介入、可回答问题、可跳过 |
| Worker 工具 | Codex CLI | 响应快，支持隔离执行 |
| 执行模式 | 串行（v2.0 可扩展并行） | 简化依赖管理 |
| 失败策略 | 智能重试 3 次 → 标记 BLOCKED | 平衡自动化与安全性 |
| 问题响应 | PM 优先回答 → 不确定则询问 User | 最小打扰原则 |
| 阻塞处理 | 跳过 → 执行其他任务 | 保持整体进度 |

---

## 4. 工作流程

```
┌──────────────────────────────────────────────────────────────┐
│                     Phase 1: 需求对齐                         │
├──────────────────────────────────────────────────────────────┤
│  [User] 提出需求                                              │
│     ↓                                                        │
│  [PM] 分解需求，生成 PRD (用户版 + 研发版)                     │
│     ↓                                                        │
│  [User] 确认 PRD → "Go"                                       │
└──────────────────────────────────────────────────────────────┘
                              |
                              ↓
┌──────────────────────────────────────────────────────────────┐
│                     Phase 2: 任务调度                         │
├──────────────────────────────────────────────────────────────┤
│  [PM] 读取 PRD → 识别第一个 PENDING 任务 (T-001)              │
│     ↓                                                        │
│  [PM] 启动 Codex Worker (后台进程，全新上下文)                 │
│     ↓                                                        │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Worker 执行中 (PM 持续监控)                  │ │
│  │                                                         │ │
│  │  [Worker] 编写代码、运行测试...                          │ │
│  │  [Worker] 遇到问题 → 输出疑问                            │ │
│  │     ↓                                                   │ │
│  │  [PM] 检测到问题 → 判断:                                 │ │
│  │     ├─ 我能回答 → 直接回复 Worker                        │ │
│  │     └─ 我不确定 → 询问 User (或标记 BLOCKED 跳过)         │ │
│  │     ↓                                                   │ │
│  │  [Worker] 收到回复 → 继续执行                            │ │
│  └─────────────────────────────────────────────────────────┘ │
│     ↓                                                        │
│  [Worker] 任务完成 → 汇报结果                                 │
│     ↓                                                        │
│  [PM] 更新 PRD 状态 (T-001 → ✅ DONE)                         │
│     ↓                                                        │
│  还有任务? ─Yes─→ 回到 "识别下一个任务"                       │
│     │                                                        │
│     No                                                       │
│     ↓                                                        │
│  🎉 所有任务完成                                              │
└──────────────────────────────────────────────────────────────┘
```

---

## 5. PM ↔ Worker 通信机制

### 5.1 架构概览

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            PM (Antigravity)                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                  │
│  │ 任务调度器   │    │ 输出监控器   │    │  问题处理器  │                  │
│  │ (Scheduler) │    │ (Monitor)   │    │  (Handler)  │                  │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘                  │
│         │                  │                  │                         │
└─────────┼──────────────────┼──────────────────┼─────────────────────────┘
          │                  │                  │
          │ codex exec       │ 轮询 stdout      │ stdin 或 重启
          ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         Worker (Codex CLI)                               │
│                                                                          │
│   [全新上下文] → 读取任务 Prompt → 执行 → 输出结果                          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.2 启动 Worker

PM 通过 Codex CLI 启动独立 Worker：

```bash
codex exec --prompt "任务描述..." --approval-mode full-auto
```

- `--approval-mode full-auto`: Worker 自动执行，无需人工批准
- 每次启动都是**全新上下文**，无历史污染

### 5.3 监控 Worker 输出

PM 实时读取 Worker 的 stdout，识别结构化标签：

| 标签 | 含义 | PM 响应 |
|-----|------|--------|
| `[PROGRESS]` | 进度更新 | 记录，更新可视化 |
| `[QUESTION]` | Worker 有问题 | 判断后回复或标记 BLOCKED |
| `[DONE]` | 任务完成 | 更新 PRD 状态，调度下一个 |
| `[ERROR]` | 执行失败 | 分析原因，决定重试或 BLOCKED |

### 5.4 向 Worker 发送回复

> ✅ **技术预研结论 (2026-02-09)**: Codex `exec` 模式为非交互式，运行中无法接收 stdin 输入。采用"重启注入"方案。

**重启注入机制**：
1. PM 检测到 Worker 输出问题 (通过 `--json` 事件流)
2. PM 终止当前 Worker 进程
3. PM 在原始 Prompt 尾部追加问题答案：
   ```
   [原始任务 Prompt]
   
   ---
   [补充信息] 关于你之前的问题 "XXX"，答案是: YYY
   ```
4. PM 重新启动 Worker，Worker 在新上下文中继续执行

### 5.5 超时策略

| 任务类型 | 超时时间 | 处理方式 |
|---------|---------|---------|
| 代码修改 | 10 分钟 | 超时后 BLOCKED |
| 测试执行 | 15 分钟 | 超时后 BLOCKED |
| 构建任务 | 20 分钟 | 超时后 BLOCKED |

**注**: 超时后 PM 记录最后输出，供 User 分析。

---

## 6. 任务状态机

### 6.1 状态定义

```
                    ┌─────────────────────────────────────────┐
                    │                                         │
                    ▼                                         │
┌─────────┐    ┌─────────────┐    ┌─────────┐           ┌─────┴───┐
│ PENDING │───▶│ IN_PROGRESS │───▶│  DONE   │           │  RETRY  │
└─────────┘    └─────────────┘    └─────────┘           └─────────┘
     │              │                                         ▲
     │              │ 失败/问题                                │
     │              ▼                                         │
     │         ┌─────────┐      User 回复后                   │
     │         │ BLOCKED │─────────────────────────────────────┘
     │         └─────────┘
     │              │
     │              │ 3 次重试失败
     │              ▼
     │         ┌─────────┐
     │         │ FAILED  │
     │         └─────────┘
     │
     │ 依赖未满足
     ▼
┌─────────┐
│ SKIPPED │ (临时跳过，待依赖完成后恢复)
└─────────┘
```

### 6.2 状态说明

| 状态 | 图标 | 说明 |
|-----|------|-----|
| PENDING | ⏳ | 等待执行 |
| IN_PROGRESS | 🔄 | 正在执行中 |
| DONE | ✅ | 已完成 |
| BLOCKED | 🚫 | 需要 User 介入 |
| RETRY | 🔁 | 等待重试 (自动) |
| FAILED | ❌ | 失败 (需人工处理) |
| SKIPPED | ⏭️ | 临时跳过 |

### 6.3 状态流转规则

| 当前状态 | 触发条件 | 目标状态 |
|---------|---------|---------|
| PENDING | PM 开始调度 | IN_PROGRESS |
| PENDING | 依赖任务 BLOCKED | SKIPPED |
| IN_PROGRESS | Worker 完成 | DONE |
| IN_PROGRESS | Worker 提问 (PM 能答) | IN_PROGRESS (继续) |
| IN_PROGRESS | Worker 提问 (PM 不确定) | BLOCKED |
| IN_PROGRESS | Worker 失败 (可重试) | RETRY |
| IN_PROGRESS | 超时 | BLOCKED |
| BLOCKED | User 回复 | RETRY |
| RETRY | 重试成功 | DONE |
| RETRY | 重试 3 次仍失败 | FAILED |
| SKIPPED | 依赖任务完成 | PENDING |

---

## 7. Worker 输出协议

> ✅ **技术预研结论 (2026-02-09)**: Codex CLI 原生支持 `--json` JSONL 事件流输出，无需自定义标签。

### 7.1 启动命令

```bash
codex exec --json --full-auto --output-last-message result.md "任务描述..."
```

| 参数 | 作用 |
|-----|------|
| `--json` | 输出 JSONL 格式事件流 |
| `--full-auto` | 全自动模式，无需人工批准 |
| `--output-last-message` | 将最终消息写入文件 |
| `--output-schema` | (可选) 约束最终响应格式 |

### 7.2 JSONL 事件类型

PM 实时解析 Worker 的 stdout JSONL 事件流：

| 事件类型 | 说明 | PM 响应 |
|---------|------|--------|
| `agent_message` | Agent 输出消息 | 记录进度 |
| `tool_call` | 调用工具 (shell, file_write 等) | 监控执行 |
| `tool_result` | 工具执行结果 | 检查成功/失败 |
| `error` | 发生错误 | 判断重试或 BLOCKED |
| `session_end` | 会话结束 | 更新 PRD 状态 |

### 7.3 PM 事件处理流程

> **v3.0 更新**: 以下流程由 Agent 的自然语言理解能力驱动，无需编写代码实现。

PM (Agent) 实时监控 Worker 输出，按以下逻辑响应：

1. **接收事件**: Agent 读取 Worker 的 JSONL 输出
2. **识别提问**: 如果 `agent_message` 包含疑问句或选择请求：
   - Agent 能回答 → 终止 Worker，将答案注入 Prompt，重启
   - Agent 不确定 → 标记 BLOCKED，跳到下一个任务
3. **处理错误**: 如果收到 `error` 事件：
   - 重试次数 < 3 → 标记 RETRY
   - 重试次数 ≥ 3 → 标记 FAILED
4. **任务完成**: 如果收到 `session_end` 且成功：
   - 更新 PRD 状态为 ✅ DONE
   - 调度下一个任务

### 7.4 问题识别策略

由于 Codex 不会显式标记"问题"，PM 需通过语义分析识别：

| 识别模式 | 示例 |
|---------|-----|
| 疑问句 | "请问 XXX 应该用哪种方式？" |
| 选择请求 | "有两个选项 A 和 B，请确认" |
| 阻塞声明 | "无法继续，因为缺少 XXX 信息" |
| 确认请求 | "是否要删除现有数据？" |

---

## 8. PM 自主决策范围

### 8.1 PM 可自行决定的问题

| 问题类型 | 示例 | PM 决策 |
|---------|------|--------|
| 技术选型 (小) | "用 async/await 还是 .then()?" | 选择更现代的方案 |
| 命名规范 | "变量名用 camelCase 还是 snake_case?" | 遵循项目现有规范 |
| 实现细节 | "用 Map 还是 List?" | 根据性能需求选择 |
| 缺失依赖 | "找不到 X 模块" | 检查并提供正确路径 |

### 8.2 PM 必须询问 User 的问题

| 问题类型 | 示例 | 处理方式 |
|---------|------|----------|
| 需求歧义 | "用户说的 'X' 是什么意思?" | 标记 BLOCKED，询问 User |
| 架构决策 | "需要新增数据库表吗?" | 询问 User |
| 风险操作 | "需要删除现有数据吗?" | 必须 User 确认 |
| 超出范围 | "这个功能不在 PRD 中" | 询问 User 是否扩展范围 |

---

## 9. 阻塞任务处理策略

当任务因等待 User 回复而阻塞时：

1. **标记状态**: 将任务标记为 `🚫 BLOCKED (等待 User)`
2. **记录问题**: 在 PRD 或 `active_context.md` 中记录阻塞原因
3. **跳过执行**: 查找下一个**无依赖关系**的 PENDING 任务
4. **继续调度**: 执行其他任务，直到:
   - 所有非阻塞任务完成
   - 或 User 回复后恢复阻塞任务

```
任务依赖图:
  T-001 (DONE)
    ├── T-002 (BLOCKED - 等待 User)
    │     └── T-004 (PENDING - 被 T-002 阻塞)
    └── T-003 (PENDING - 无依赖) ← PM 跳到这里执行
```

---

## 10. 不做什么 (Out of Scope v2.0)

- ❌ 不支持并行执行（v2.0，未来可扩展）
- ❌ 不支持跨项目任务派发
- ❌ 不支持 Web UI 监控面板

---

## 11. 风险与挑战

### 11.1 运行时风险

| 风险 | 影响 | 缓解措施 |
|-----|------|---------|
| ⚠️ Worker 卡死 | 任务无限等待 | PM 设置超时（15分钟），强制终止 |
| ⚠️ PM 误判问题 | 回答错误导致代码问题 | PM 对不确定的问题标记 BLOCKED |
| ⚠️ 阻塞任务过多 | 整体进度停滞 | 通知 User 批量处理阻塞问题 |
| ⚠️ Git 冲突 | 代码丢失 | 每个任务完成后自动 commit |

### 11.2 技术预研依赖 ✅ 已完成

> ✅ **预研完成时间**: 2026-02-09 17:16

| 预研项 | 验证结论 | 采用方案 |
|-------|---------|---------|
| 🔬 **Codex CLI 交互能力** | ⚠️ 有限 - `exec` 模式不支持运行时 stdin | ✅ 采用"重启注入"方案 (第 5.4 节已更新) |
| 🔬 **结构化输出可行性** | ✅ 原生支持 `--json` JSONL 事件流 | ✅ 采用原生 JSONL (第 7 节已更新) |

**关键发现**:
- Codex CLI 原生 `--json` 比自定义标签更可靠
- PM 需通过语义分析识别 Agent 提问，而非依赖显式标签

---

## 12. 成功指标

| 指标 | 目标 | 说明 |
|------|------|------|
| **自动化率** | ≥ 80% | 无需 User 介入即可完成的任务比例 |
| **PM 自主决策率** | ≥ 70% | Worker 问题由 PM 直接回答的比例 |
| **阻塞恢复时间** | < 5 分钟 | User 回复后恢复执行的时间 |
| **整体完成时间** | 10 任务 / 30 分钟 | 端到端效率 |

---

**请确认以上内容，说 "Go" 进入技术评审**
